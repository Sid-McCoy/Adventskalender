<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Snake – Fancy Edition (Langsam & Groß)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="style.css">
</head>
<body>
<div id="game-container">
  <div id="ui">
    <div>Punkte: <span id="score">0</span></div>
    <div>| Highscore: <span id="highscore">0</span></div>
    <button id="pauseBtn">Pause</button>
    <button id="resetBtn">Reset</button>
    <button id="themeBtn">Toggle Theme</button>
  </div>
  <canvas id="game" width="600" height="600"></canvas>
  <div id="mobile-controls">
    <div style="width:56px"></div>
    <button class="ctrl-btn" data-dir="up">▲</button>
    <div style="width:56px"></div>
    <button class="ctrl-btn" data-dir="left">◀</button>
    <button class="ctrl-btn" data-dir="down">▼</button>
    <button class="ctrl-btn" data-dir="right">▶</button>
  </div>
</div>
<script>
const gridSize = 30;          // Größeres Feld
let tileSize = 20;            // Automatisch gesetzt unten
let snake = [{x: 15, y: 15}];
let direction = {x: 0, y: -1};
let nextDir = direction;
let apple = {x: 5, y: 5};
let score = 0;
let highscore = Number(localStorage.snakeHighscore||0);
let paused = false, dead = false, growing = 0;
let moveDelay = 140;          // SLOWER SNAKE! (vorher ca. 65ms)
let lastMove = 0;
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const highscoreEl = document.getElementById('highscore');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');
const ctrlBtns = document.querySelectorAll('.ctrl-btn');
const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

highscoreEl.textContent = highscore;

function resizeCanvas() {
  // Immer quadratisch und maximal responsive
  let size = Math.min(window.innerWidth * 0.97, window.innerHeight * 0.8, 720);
  if(window.innerWidth < 700) size = Math.min(window.innerWidth * 0.98, window.innerHeight * 0.7);
  canvas.width = canvas.height = size;
  tileSize = size / gridSize;
}
window.addEventListener('resize', resizeCanvas);

function resetGame() {
  snake = [{x: Math.floor(gridSize/2), y: Math.floor(gridSize/2)}];
  direction = {x: 0, y: -1};
  nextDir = direction;
  spawnApple();
  score = 0;
  paused = false;
  dead = false;
  growing = 2;
  scoreEl.textContent = score;
  pauseBtn.textContent = 'Pause';
}
function spawnApple() {
  do {
    apple.x = Math.floor(Math.random() * gridSize);
    apple.y = Math.floor(Math.random() * gridSize);
  } while (snake.some(s => s.x===apple.x && s.y===apple.y));
}
function setDir(dx, dy) {
  if (dead || paused) return;
  // No reverse
  if (dx===-direction.x && dy===-direction.y) return;
  nextDir = {x: dx, y: dy};
}
document.addEventListener('keydown', e => {
  if (dead) { if (e.key==="Enter") resetGame(); return; }
  if (["w","ArrowUp"].includes(e.key)) setDir(0,-1);
  if (["s","ArrowDown"].includes(e.key)) setDir(0,1);
  if (["a","ArrowLeft"].includes(e.key)) setDir(-1,0);
  if (["d","ArrowRight"].includes(e.key)) setDir(1,0);
  if (e.key===" " || e.key==="Escape") togglePause();
});
ctrlBtns.forEach(btn => {
  btn.addEventListener('touchstart', e=>{
    e.preventDefault();
    const dir = btn.dataset.dir;
    if (dir==="up") setDir(0,-1);
    if (dir==="down") setDir(0,1);
    if (dir==="left") setDir(-1,0);
    if (dir==="right") setDir(1,0);
  });
});
pauseBtn.onclick = togglePause;
resetBtn.onclick = () => { resetGame(); };

function togglePause() {
  if (dead) return;
  paused = !paused;
  pauseBtn.textContent = paused ? 'Weiter' : 'Pause';
}
function update(now) {
  if (paused || dead) return;
  if (!lastMove) lastMove = now;
  if (now - lastMove < moveDelay) return;
  lastMove = now;
  direction = nextDir;
  const head = {...snake[0]};
  head.x += direction.x; head.y += direction.y;

  // Check wall
  if (head.x < 0 || head.x >= gridSize || head.y < 0 || head.y >= gridSize ||
      snake.some(s => s.x === head.x && s.y === head.y)) {
    dead = true;
    if (score > highscore) {
      highscore = score;
      localStorage.snakeHighscore = score;
      highscoreEl.textContent = score;
    }
    pauseBtn.textContent = 'Restart';
    draw();
    return;
  }

  snake.unshift(head);

  if (head.x === apple.x && head.y === apple.y) {
    score++;
    growing += 2;
    scoreEl.textContent = score;
    spawnApple();
  }

  if (growing > 0) growing--;
  else snake.pop();
}
function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Grid lines (subtle)
  ctx.save();
  ctx.strokeStyle = "rgba(50,255,150,0.13)";
  ctx.lineWidth = 0.5;
  for(let i=1; i<gridSize; ++i){
    ctx.beginPath();
    ctx.moveTo(i*tileSize,0); ctx.lineTo(i*tileSize,canvas.height); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0,i*tileSize); ctx.lineTo(canvas.width,i*tileSize); ctx.stroke();
  }
  ctx.restore();

  // Apple
  ctx.save();
  ctx.shadowColor = "#fc2e5e";
  ctx.shadowBlur = 30;
  ctx.fillStyle = "#fc2e5e";
  ctx.beginPath();
  ctx.arc((apple.x+0.5)*tileSize, (apple.y+0.5)*tileSize, tileSize*0.44, 0, 2*Math.PI);
  ctx.fill();
  ctx.restore();

  // Snake
  snake.forEach((seg,i)=>{
    ctx.save();
    ctx.shadowColor = i===0 ? "#2efc71" : "#45c9e6";
    ctx.shadowBlur = i===0 ? 18 : 6;
    ctx.fillStyle = i===0 ? "#00e673" : `#29cfff`;
    ctx.beginPath();
    ctx.arc((seg.x+0.5)*tileSize, (seg.y+0.5)*tileSize, tileSize*0.42, 0, 2*Math.PI);
    ctx.fill();
    ctx.restore();
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.arc((seg.x+0.63)*tileSize, (seg.y+0.4)*tileSize, tileSize*0.12, 0, 2*Math.PI);
    ctx.fill();
    ctx.restore();
  });
  // Augen
  if (!dead) {
    const head = snake[0];
    const offX = direction.x * 3, offY = direction.y * 3;
    ctx.save();
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.arc((head.x+0.37)*tileSize+offX, (head.y+0.4)*tileSize+offY, tileSize*0.09, 0, 2*Math.PI);
    ctx.arc((head.x+0.63)*tileSize+offX, (head.y+0.4)*tileSize+offY, tileSize*0.09, 0, 2*Math.PI);
    ctx.fill();
    ctx.fillStyle = "#111";
    ctx.beginPath();
    ctx.arc((head.x+0.37)*tileSize+offX, (head.y+0.44)*tileSize+offY, tileSize*0.04, 0, 2*Math.PI);
    ctx.arc((head.x+0.63)*tileSize+offX, (head.y+0.44)*tileSize+offY, tileSize*0.04, 0, 2*Math.PI);
    ctx.fill();
    ctx.restore();
  }
  // Tod
  if (dead) {
    ctx.save();
    ctx.globalAlpha = 0.93;
    ctx.fillStyle = "#000a";
    ctx.fillRect(0,canvas.height/2-52,canvas.width,100);
    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    ctx.font = "bold 2em Segoe UI";
    ctx.fillText("Game Over", canvas.width/2, canvas.height/2-10);
    ctx.font = "1em Segoe UI";
    ctx.fillText("Punkte: "+score, canvas.width/2, canvas.height/2+18);
    ctx.font = "italic 0.9em Segoe UI";
    ctx.fillText("Drücke Enter oder 'Restart'", canvas.width/2, canvas.height/2+44);
    ctx.restore();
  }
}
function loop(now) {
  update(now||0);
  draw();
  requestAnimationFrame(loop);
}
resizeCanvas();
resetGame();
loop();

// Touch Swipe für Mobile
let startX=0, startY=0;
canvas.addEventListener('touchstart', e=>{
  const t = e.touches[0];
  startX = t.clientX; startY = t.clientY;
});
canvas.addEventListener('touchmove', e=>{
  if (!startX && !startY) return;
  const t = e.touches[0];
  const dx = t.clientX - startX, dy = t.clientY - startY;
  if (Math.abs(dx) > 20 || Math.abs(dy) > 20) {
    if (Math.abs(dx) > Math.abs(dy)) setDir(dx>0?1:-1,0);
    else setDir(0,dy>0?1:-1);
    startX = startY = 0;
  }
});

if(isMobile) document.getElementById('mobile-controls').style.display='flex';

const themeBtn = document.getElementById('themeBtn');
const bodyEl = document.body;

// Apply saved theme on load
const savedTheme = localStorage.getItem('themePreference');
if (savedTheme === 'light') {
  bodyEl.classList.add('light-theme');
}

themeBtn.addEventListener('click', () => {
  bodyEl.classList.toggle('light-theme');
  if (bodyEl.classList.contains('light-theme')) {
    localStorage.setItem('themePreference', 'light');
  } else {
    localStorage.setItem('themePreference', 'dark');
  }
});
</script>
</body>
</html>
